int count = 0;
double sData = 0;                            // амплитуда размаха ЭМГ-сигнала
//int val[arrSize];                            // массив для хранения оцифрованных значений ЭМГ-сигнала
int i = 0;                                   // переменная-счетчик 
int emg = 0;                                 // переменная для хранения оцифрованного значения сигнала  
int maxV = 0, minV = 0;
#define arrSize 32                           // размер массива оцифрованных значений для поиска в нем максимума и минимума сигнала
#define threshold 40                         // порог срабатывания светодиода (может требовать подстройки под конкретного человека)
#define LED 13
/*
Pulse
Оцифровывает сигнал c сенсора пульса - фотоплетизмографа (Pulse или photoplethysmography - PPG), подключенного ко входу А0 платы Arduino и отправляет для отображения в 
программу визуализации от BiTronics, скачать ее можно тут: http://www.bitronicslab.com/guide/ 
Справочник по командам языка Arduino: http://arduino.ru/Reference 
*/

#include <TimerOne.h> // подключаем библиотеку TimerOne для задействования функций Таймера1 
/* предварительно данную библиотеку надо установить, для чего скачиваем ее 
на странице http://www.bitronicslab.com/guide/ , распаковываем архив и помещаем папку TimerOne
внутрь папки libraries, находящейся тут: "Мои документы/Arduino/libraries" 
Подробнее о TimerOne см. тут: http://robocraft.ru/blog/arduino/614.html */

int val = 0;                                 // переменная для хранения оцифрованного значения сигнала  
          
// функция sendData вызывается каждый раз, когда срабатывает прерывание Таймера1 (проходит заданное число микросекунд)
void sendData() {
  Serial.write("A0");                       // записываем в Serial-порт имя поля в программе для визуализации, куда надо выводить сигнал
                                            // всего в этой программе 4 поля, которые имеют имена A0, A1, A2, A3 (сверху вниз, по порядку их 
                                            // расположения в окне программы)
  val = analogRead(A0);                     // записываем в переменную val оцифрованное значение сигнала с ножки А0 на Arduino.
                                            // val может принимать значение в диапазоне от 0 до 1023, см. http://arduino.ru/Reference/AnalogRead 
  Serial.write(map(val, 0, 1023, 0, 255));  // записываем в Serial-порт значение val, предварительно отнормированное на диапазон значений от 0 до 255,
 sData =  0.4*sData + 0.6*(maxV - minV); // чтобы срабатывание мотора было более плавным, раскомментируйте эту строку и закомментируйте следующую. Теория: https://ru.wikipedia.org/wiki/Экспоненциальное_сглаживание 
   // sData = maxV - minV;                      // определяем максимальный размах сигнала ЭМГ, записанного в массив val[]
    maxV = 0;                                 // обнуляем значение переменной maxV, в которой хранится значение максимального элемента массива val[] 
    minV = 255;           
 if (sData > threshold)                       // если размах сигнала больше порога срабатывания
    digitalWrite(LED, HIGH);                  // устанавливаем логическую "1" на выход LED (высокий уровень напряжения на выходе - светодиод включается)
 else
    digitalWrite(LED, LOW);                                  // см. описание команды map:  http://arduino.ru/Reference/Map 
  }

// функция setup вызывается однократно при запуске Arduino
void setup() {
  Serial.begin(115200);                    // инициализируем Serial-порт на скорости 115200 Кбит/c. 
                                           // такую же скорость надо установить в программе для визуализации
  Timer1.initialize(3000);                 // инициализируем Таймер1, аргументом указываем интервал срабатывания - 3000 микросекунд 
                                           // (1 000 000 микросекунд = 1 сек)
  Timer1.attachInterrupt(sendData);        // как только проходит 3000 микросекунд - наступает прерывание (вызывается функция sendData)
}

void loop(){
    Serial.print(count);
  Serial.print(" ");
  delay (1000);
  count = count + 1;
}
// а в бесконечном цикле мы ничего не делаем. Таймер1 сам будет вызывать функцию sendData через каждые 3000 микросекунд
